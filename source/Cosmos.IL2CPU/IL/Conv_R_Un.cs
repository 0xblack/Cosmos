using System;
using CPUx86 = Cosmos.Assembler.x86;

namespace Cosmos.IL2CPU.X86.IL
{
    /// <summary>
    /// Converts the unsigned integer value on top of the evaluation stack to F (native float) it can be double or some FPU extended precision Floating Point
    /// type as the weird 80 bit float of x87). For now we assume it to be always equal to double.
    /// </summary>
    [Cosmos.IL2CPU.OpCode( ILOpCode.Code.Conv_R_Un )]
     
    public class Conv_R_Un : ILOp
    {
        
        public Conv_R_Un( Cosmos.Assembler.Assembler aAsmblr )
            : base( aAsmblr )
        {
        }

        public override void Execute( MethodInfo aMethod, ILOpCode aOpCode )
        {
            var xValue = aOpCode.StackPopTypes[0];
            var xValueIsFloat = TypeIsFloat(xValue);
            var xValueSize = SizeOfType(xValue);

            if (xValueSize > 8)
            {
                //EmitNotImplementedException( Assembler, aServiceProvider, "Size '" + xSize.Size + "' not supported (add)", aCurrentLabel, aCurrentMethodInfo, aCurrentOffset, aNextLabel );
                throw new NotImplementedException();
            }
			//TODO if on stack a float it is first truncated, http://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.conv_r_un.aspx
            if (!xValueIsFloat)
            {
                switch (xValueSize)
                {
                    case 1:
                    case 2:
                    case 4:
                    // I cannot find a way to create that Label so the method cannot be implemented! Sad :-(
#if false
                /*
                 * x86 assembler generated by Clang 3.4-1:
                 * 
                 * .LCPI1_0:
                 * .quad	4841369599423283200     # double 4503599627370496
                 * .text
                 * .globl	uint2double
                 * .align	16, 0x90
                 * .type	uint2double,@function
                 * uint2double:                            # @uint2double
                 * # BB#0:
                 * sub	esp, 12
                 * movsd	xmm0, qword ptr [.LCPI1_0]
                 * movd	xmm1, dword ptr [esp + 16]
                 * orps	xmm1, xmm0
                 * subsd	xmm1, xmm0
                 * movsd	qword ptr [esp], xmm1
                 * # We don't want to write the value in the x87 registers (this should be done for x86 calling convention) we want it into the stack
                 * # fld	qword ptr [esp]
                 * add	esp, 12
                 * ret
                 * 
                 * .Ltmp1:
                 *.size	uint2double, .Ltmp1-uint2double
                 *
                 * .section	.rodata.cst8,"aM",@progbits,8
                 *.align	8
                 */
                        new CPUx86.Sub { DestinationReg = CPUx86.Registers.ESP, SourceValue = 12 };
                        new CPUx86.SSE.MoveSD { DestinationReg = CPUx86.Registers.XMM0, SourceValue = 4841369599423283200, SourceIsIndirect = true };
                        new CPUx86.SSE.MoveD { DestinationReg = CPUx86.Registers.XMM1, SourceReg = CPUx86.Registers.ESP, DestinationDisplacement = 16 };
                        new CPUx86.SSE.OrPS { DestinationReg = CPUx86.Registers.XMM1, SourceReg = CPUx86.Registers.XMM0 };
                        new CPUx86.SSE.SubSD { DestinationReg = CPUx86.Registers.XMM1, SourceReg = CPUx86.Registers.XMM0 };
                        new CPUx86.SSE.MoveSD { DestinationReg = CPUx86.Registers.ESP, SourceReg = CPUx86.Registers.XMM1, DestinationIsIndirect = true };
                        new CPUx86.Sub { DestinationReg = CPUx86.Registers.ESP, SourceValue = 12 }; 
#endif
                    /*
                     * This is the original code. It cannot work as ConvertSI2SS want a *signed* int as input but here we have an *unsigned* int 
                     * indeed we get always 0!
                     */
                        new CPUx86.Mov { SourceReg = CPUx86.Registers.ESP, DestinationReg = CPUx86.Registers.EAX, SourceIsIndirect = true };
                        new CPUx86.SSE.ConvertSI2SS { SourceReg = CPUx86.Registers.EAX, DestinationReg = CPUx86.Registers.XMM0 };
                        new CPUx86.SSE.MoveSS { SourceReg = CPUx86.Registers.XMM0, DestinationReg = CPUx86.Registers.ESP, DestinationIsIndirect = true };
                        // This will be the correct thing to do instead to return a random value but Il2CPU crashes!
                        //EmitNotImplementedException(Assembler, GetServiceProvider(), "Conv_I: SourceSize " + xSource + " not supported!", mCurLabel, mMethodInformation, mCurOffset, mNextLabel);
                        break;
                    case 8:
                    //new CPUx86.Add { DestinationReg = CPUx86.Registers.ESP, SourceValue = 4 };
                    //break;
                    default:
                        //EmitNotImplementedException( Assembler, GetServiceProvider(), "Conv_I: SourceSize " + xSource + " not supported!", mCurLabel, mMethodInformation, mCurOffset, mNextLabel );
                        throw new NotImplementedException("Conv_R_Un with type " + xValue + " not supported!");
                }
            }
            else
            {
                throw new NotImplementedException();
            }
        }
    }
}